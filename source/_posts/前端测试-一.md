---
title: 前端测试-一
date: 2021-06-10 11:43:31
tags: JEST
category: 前端
cover: https://st0.dancf.com/gaoding-material/2020-06-05/1591324273-ukyZ5.jpg
---

## 官网
[官网](https://jestjs.io/)

`零配置`: Jest的目标是在大部分JavaScript项目上实现开箱即用，无需配置
`快照`: 构建能够轻松追踪大Object的测试。快照可以独立于测试代码，也可以集成进代码行内。
`隔离的`: 测试程序在自己的进程并行运算以最大限度地提高性能
`优秀的` api: 从it 到 expect - Jest将整个工具包放在一个地方。好书写，好维护，非常方便。

## 安装
```js
npm install jest@24.8.0 --save-dev
```

package.json 中的script添加如下代码：

```json
"test": "jest"
```

match.js:
```js
function add(a, b) {
    return a + b;
}

module.exports = {
    add
}
```

match.test.js:
```js
const match = require('./match.js');
const {add} = match;
test('测试加法 3 + 7', () => {
    expect(add(3,7)).toBe(10);
})
```

```bash
npm run test
```

暴露jest配制：

```bash
npx jest --init
```
![jest](/img/jest/1.jpg)

此时可以看到有一个jest.config.js
测试覆盖率：

```js
npx jest --coverage
```
![jest](/img/jest/2.jpg)


`注意`: esModule模块引入需要用babel转换成commonjs规范
```bash
npm install @babel/core@7.4.5 @babel/preset-env@7.4.5 -D
```

原理：
- jest(babel-jest)
- babel-core
- 取 .babelrc 配置
- 在运行测试之前， 结合babel, 选把你的代码做一次转化
- 运行转化过的测试用例代码

匹配器：
- toBe 引用相等
- toEqual 内容相等
- toBeNull 内容是不是null
- toBeUndefined 未定义过
- toBeDefined 被定义过
- toBeTruthy 是不为真
- toBeFalsy 是未为假
- not 取反
- boBeCreaterThan 比某个数大
- boBeLessThan 比某个数小
- boBeCreaterThanOrEqual 大于等于
- boBeCloseTo 去浮点小数
> String
- boMatch 包含 可以用正则
> Array, Set
- toContain 包含
- toThrow 抛出异常 抛错的内容一致
> 监控所有改动

```json
"scripts": {
    "test": "jest --watchAll", // a 模式
    "test": "jest --watch", // o 模式
    "coverage": "jest --coverage"
},
```

npm run test 出如下操作选项：

› Press `f` to run only failed tests.
› Press `o` to only run tests related to changed files.
› Press `p` to filter by a filename regex pattern.
› Press `t` to filter by a test name regex pattern.
› Press `q` to quit watch mode.
› Press `Enter` to trigger a test run.

异步代码测试:
```js
import axios from 'axios';
export const fetchData = (fn) => {
    axios.get('http://www.dell-lee.com/react/api/demo.json').then((response) => {
         fn(response.data)
    })
}

// fetchData.test.js
import { fetchData } from './fetchData';
test('fetchData 返回结果为 { success: true }', (done) => {
    fetchData((data) => {
        expect(data).toEqual({
            success: true 
        })
        done();
    })
})
```
如果回调是promiss
```js
test('fetchData 返回结果为 { success: true }', () => {
    return fetchData().then((response) => {
        expect(response.data).toEqual({ success: true });
    })
})
```
如果catch 加一局expect.assertions
```js

// 404 response
test('fetchData 返回结果为 { success: true }', () => {
    expect.assertions(1); // 至少一个expect
    return fetchData().catch((e) => {
        expect(e.toString().indexOf('404') > -1).toBe(true);
    })
})
```
```js
test('fetchData 返回结果为 { success: true }', () => {
    return expect(fetchData()).resolves.toMatchObject({
        data: { success: true}
    })
})

test('fetchData 返回结果 404', () => {
    return expect(fetchData()).rejects.toThrow();
})
```
```js
// async/await
test('fetchData 返回结果为 { success: true }', async () => {
    await expect(fetchData()).resolves.toMatchObject({
        data: { success: true}
    })
})

test('fetchData 返回结果 404', async () => {
    await expect(fetchData()).rejects.toThrow();
})
```
```js

test('fetchData 返回结果为 { success: true }', async () => {
    const response = await fetchData()
    expect(response.data).toEqual({ success: true })
})
```
## 钩子函数
- beforeAll
- beforeEach
- afterEach
- afterAll
> describe 分组

```js
describe('测试所有Counter相关代码', () => {
    describe('测试增加相关的代码', () => {
        test('测试 Counter 中的 addOne 方法', () => {
            console.log('测试 Counter 中的 addOne 方法');
            counter.addOne()
            expect(counter.number).toBe(1);
        })
        test('测试 Counter 中的 addTwo 方法', () => {
            console.log('测试 Counter 中的 addTwo 方法');
            counter.addTwo()
            expect(counter.number).toBe(2);
        })
    })
    
    describe('测试减少相关的代码', () => {
        test('测试 Counter 中的 minusOne 方法', () => {
            console.log('测试 Counter 中的 minusOne 方法');
            counter.minusOne()
            expect(counter.number).toBe(-1)
        })
        test('测试 Counter 中的 minusTwo 方法', () => {
            console.log('测试 Counter 中的 minusTwo 方法');
            counter.minusTwo()
            expect(counter.number).toBe(-2)
        })
    })
})
```
![jest](/img/jest/3.jpg)

### 钩子函数的作用域
test.only() 只执行某条测试用例

### jest中的Mock
jest.fn() mock 函数

```js
import { runCallback } from './demo';
// error:
test('测试 runCallback', () => {
    const func = () => {
        return 'hello';
    }
    
    expect(runCallback(func)).toBe('hello');
})

// right:
test('测试 runCallback', () => {
    const func = jest.fn(); // mock 函数, 捕获函数的调用
    runCallback(func);
    expect(func).toBeCalled(); // 函数是否被调用
})
```
func.mock:

- calls: [ [] ], 调用的情况 （参数）
- instances: [ undefined ], 实例this的指向
- invocationCallOrder: [ 1 ], 执行顺序
- results: [ { type: ‘return’, value: undefined } ] 执行的结果

```js
test('测试 runCallback 调用 次数', () => {
    const func = jest.fn();
    runCallback(func);
    runCallback(func);
    runCallback(func);
    expect(func.mock.calls.length).toBe(3)
})

test('测试 runCallback 调用 参数', () => {
    const func = jest.fn();
    runCallback(func);
    expect(func.mock.calls[0]).toEqual(['abc'])
})

test('测试 runCallback 调用 返回', () => {
    const func = jest.fn();
    // const func = jest.fn(() => '456');
    func.mockReturnValueOnce('laosu').mockReturnValueOnce('laozhang').mockReturnValueOnce('laoma')
    
    runCallback(func);
    runCallback(func);
    runCallback(func);
    expect(func.mock.calls[0]).toEqual(['abc'])


    console.log(func.mock);
})

test('测试 runCallback 调用 返回', () => {
    const func = jest.fn();
    // const func = jest.fn(() => '456');
    // 链式
    // func.mockReturnValueOnce('laosu').mockReturnValueOnce('laozhang').mockReturnValueOnce('laoma')
    func.mockReturnValue('laosu')
    
    runCallback(func);
    runCallback(func);
    runCallback(func);

    expect(func.mock.results[0].value).toBe('laosu')
    console.log(func.mock);
})
```
![jest](/img/jest/3.jpg)