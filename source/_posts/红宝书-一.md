---
title: 红宝书-一
date: 2021-06-11 13:54:24
tags: javascript
category: 前端
cover: /img/hbs.jpg
---

## 第一章
JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分：
- `ECMAScript`：由 ECMA-262 定义并提供核心功能。
- `文档对象模型（DOM）`：提供与网页内容交互的方法和接口。
- `浏览器对象模型（BOM）`：提供与浏览器交互的方法和接口。

## 第 2 章 HTML 中的 JavaScript
### 2.1 `<script>`元素
`<script>`元素有下列 8 个属性:
- `async`：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其
他脚本加载。只对外部脚本文件有效。
- `charset`：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不
在乎它的值。
- `crossorigin`：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS crossorigin=  "anonymous"配置文件请求不必设置凭据标志。crossorigin="use-credentials"设置凭据 标志，意味着出站请求会包含凭据。
- `defer`：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。
- `integrity`：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。
- `language`：废弃。最初用于表示代码块中的脚本语言（如"JavaScript"、"JavaScript 1.2"或"VBScript"）。大多数浏览器都会忽略这个属性，不应该再使用它。
- `src`：可选。表示包含要执行的代码的外部文件
- `type`：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是"text/javascript"，尽管"text/javascript"和"text/ecmascript"都已经废弃了。JavaScript 文件的 MIME 类型通常是"application/x-javascript"，不过给type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。

> `注意` 按照惯例，外部 JavaScript 文件的扩展名是.js。这不是必需的，因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript扩展语言（如TypeScript，或React的 JSX）转译为JavaScript提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。

#### 2.1.1 标签位置
#### 2.1.2 推迟执行脚本
HTML 4.01 为`<script>`元素定义了一个叫 `defer` 的属性
>  也就是说，脚本会被延迟到整个页面都解析完毕后再运行, 相当于告诉浏览器立即下载，但延迟执行

#### 2.1.3 异步执行脚本
HTML5 为`<script>`元素定义了 `async` 属性
> 与 defer 不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行，比如：

```html
<!DOCTYPE html> 
<html> 
 <head> 
 <title>Example HTML Page</title> 
 <script async src="example1.js"></script> 
 <script async src="example2.js"></script> 
 </head> 
 <body> 
 <!-- 这里是页面内容 --> 
 </body> 
</html>
```

#### 2.1.4 动态加载脚本
```js
let script = document.createElement('script'); 
script.src = 'gibberish.js'; 
document.head.appendChild(script);
```
以这种方式创建的`<script>`元素是以异步方式加载的，相当于添加了 async 属性。不过这样做可能会
有问题，因为所有浏览器都支持 createElement()方法，但不是所有浏览器都支持 async 属性。因此，
如果要统一动态脚本的加载行为，可以明确将其设置为同步加载:
```js
let script = document.createElement('script'); 
script.src = 'gibberish.js'; 
script.async = false; 
document.head.appendChild(script);
```
以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先
级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些
动态请求文件的存在，可以在文档头部显式声明它们：
```html
<link rel="preload" href="gibberish.js">
```


### 2.2 行内代码与外部文件
外部加载的理由：
- `可维护性`。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML 页面来编辑代码。
- `缓存`。浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
-` 适应未来`。通过把 JavaScript 放到外部文件中，就不必考虑用 XHTML 或前面提到的注释黑科技。包含外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。

### 2.3 文档模式
最初的文档模式有两种：
- `混杂模式`（quirks mode）在所有浏览器中都以省略文档开头的 doctype 声明作为开关
- `标准模式` （standards mode）
- `准标准模式`（almost standards mode）过渡性文档类型（Transitional）和框架集文档类型（Frameset）来触发

### 2.4 `<noscript>`元素
- 浏览器不支持脚本；
- 浏览器对脚本的支持被关闭

### 2.5 小结

- 要包含外部 JavaScript 文件，必须将 src 属性设置为要包含文件的 URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。
- 所有`<script>`元素会依照它们在网页中出现的次序被解释。在不使用 defer 和 async 属性的情况下，包含在`<script>`元素中的代码必须严格按次序解释。
- 对不推迟执行的脚本，浏览器必须解释完位于`<script>`元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把`<script>`元素放到页面末尾，介于主内容之后及`</body>`标签之前。
- 可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。
- 可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
- 通过使用`<noscript>`元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则`<noscript>`元素中的任何内容都不会被渲染。

### 2.6 笔记
![defer & async](/img/js/1.jpg)
[LinkPreload资料](http://eux.baidu.com/blog/fe/link-preload-%E6%A0%87%E7%AD%BE)

### 2.7 问题
- script 标签中 integrity 属性的作用?

> 对于从DNS加载拉取的 script，为了防止dns被攻击，文件内容被篡改。script标签支持加入integrity属性。这个属性的值是目标文件的sha256、sha384 及 sha512的hash值。如果目标文件与此hash值对不上，浏览器拒绝访问。

> https://developer.mozilla.org/zh-CN/docs/Web/Security/Subresource_Integrity

> 子资源完整性(SRI)是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。

- crossorigin 属性如何携带凭据？

> crossorigin="use-credentials" 可以携带cookie。
    crossorigin="use-credentials" 可以携带cookie。
    同时后端也要 Access-Control-Allow-Origin必须为具体的Origin，而且 Access-Control-Allow-Credentials 必须为true

- defer属性的作用，defer属性加载的脚本执行顺序如何？

    作用：将script标签放在html解析后延迟加载。会立即下载，但是不会立即执行。
    原则上，defer的两个script标签依然会按照顺序执行，但实际情况并不是很好。所以不建议两个有依赖的script标签都配置defer

- async属性的作用，async属性加载的脚本执行顺序如何？

    作用：将script标签放在html解析后异步加载。
    会立即下载，但是不会立即执行。async的两个script标签不会按照顺序执行。所以不建议在配置了async的script标签内操作dom

- JS动态加载脚本前如何让浏览器预加载？
    - ink rel=preload属性。可以告诉浏览器我未来要加载某个script标签。可以提前解析
    - [资料一](http://eux.baidu.com/blog/fe/link-preload-%E6%A0%87%E7%AD%BE)
    - [资料二](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485614&idx=1&sn=b25bac7cfbb02bdcab76b41f10a4bffb&source=41#wechat_redirect)


## 第3章
### 3.1.1 区分大小写
#### 3.1.2 标识符
 - 第一个字符必须是一个字母、下划线（_）或美元符号（$）；
 - 剩下的其他字符可以是字母、下划线、美元符号或数字。

> `注意` 关键字、保留字、true、false 和 null 不能作为标识符。具体内容请参考 3.2 节。

#### 3.1.3 注释
- 单行
- 多行

#### 3.1.4 严格模式
- 严格模式（strict mode）： ECMAScript 5 增加的预处理指令。

    严格模式是一种不同的 JavaScript 解析和执
    行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对
    整个脚本启用严格模式，在脚本开头加上这一行：
    "use strict";

也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可：
```js
function doSomething() { 
 "use strict"; 
 // 函数体 
}
```
#### 3.1.5 语句
ECMAScript 中的语句以分号结尾

### 3.2 关键字与保留字
ECMA-262 第 6 版规定的所
有关键字如下：
- break do in typeof 
- case else instanceof var 
- catch export new void 
- class extends return while 
- const finally super with 
- continue for switch yield 
- debugger function this 
- default if throw 
- delete import try
规范中也描述了一组未来的保留字

始终保留: </br>
enum </br>
严格模式下保留: </br>
implements package public </br>
interface protected static </br>
let private 
模块代码中保留: </br>
await

### 3.3 变量
- var 函数作用域， 变量提升
- const 
- let 块作用域

```js
if (true) { 
 var name = 'Matt'; 
 console.log(name); // Matt 
} 
console.log(name); // Matt
```

```js
if (true) { 
 let age = 26; 
 console.log(age); // 26 
} 
console.log(age); // ReferenceError: age 没有定义
```
#### 2. 全局声明
```js
var name = 'Matt'; 
console.log(window.name); // 'Matt' 
let age = 26; 
console.log(window.age); // undefined
```
#### 3. 条件声明

```html
<!-- 使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。 -->
<script>
 var name = 'Nicholas'; 
 let age = 26; 
</script> 
<script> 
 // 假设脚本不确定页面中是否已经声明了同名变量
 // 那它可以假设还没有声明过
 var name = 'Matt'; 
 // 这里没问题，因为可以被作为一个提升声明来处理
 // 不需要检查之前是否声明过同名变量
 let age = 36; 
 // 如果 age 之前声明过，这里会报错
</script> 
<!-- 使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。 -->
<script> 
 let name = 'Nicholas'; 
 let age = 36; 
</script> 
<script> 
 // 假设脚本不确定页面中是否已经声明了同名变量
 // 那它可以假设还没有声明过
 if (typeof name === 'undefined') { 
 let name; 
 } 
 // name 被限制在 if {} 块的作用域内
 // 因此这个赋值形同全局赋值
 name = 'Matt'; 
 try { 
 console.log(age); // 如果 age 没有声明过，则会报错
 } 
 catch(error) { 
 let age;
 } 
 // age 被限制在 catch {}块的作用域内
 // 因此这个赋值形同全局赋值
 age = 26; 
</script>
```

> `注意` 不能使用 let 进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变
得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。

#### 4. for 循环中的 let 声明
```js 
for (var i = 0; i < 5; ++i) { 
 // 循环逻辑 
} 
console.log(i); // 5

for (let i = 0; i < 5; ++i) {
 // 循环逻辑
} 
console.log(i); // ReferenceError: i 没有定义

for (var i = 0; i < 5; ++i) { 
 setTimeout(() => console.log(i), 0) 
} 
// 你可能以为会输出 0、1、2、3、4 
// 实际上会输出 5、5、5、5、5

for (let i = 0; i < 5; ++i) { 
 setTimeout(() => console.log(i), 0) 
} 
// 会输出 0、1、2、3、4
```
#### 3.3.3 const 声明
const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且
尝试修改 const 声明的变量会导致运行时错误。
#### 3.3.4 声明风格及最佳实践
- 1. 不使用 var
- 2. const 优先，let 次之

### 3.4 数据类型